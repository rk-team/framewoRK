<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/main.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script src="javascripts/jquery-2.0.3.js"></script>
    <script src="javascripts/highlight.pack.js"></script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>framewoRK by rk-team</title>
  </head>

  <body>
    <h1>Bienvenue sur trackeet, le tutoriel de framewoRK !</h1>

<div class="warning">Ce tutoriel est en cours de développement !<br />
Le dépôt étant privé pour le moment, les sources ne sont disponibles que pour les utilisateurs référencés.<br /> 
Il n'est que partiellement testé, et fait régulièrement <span class="todo">référence à des pages</span> d'une documentation qui n'existe pas encore.<br />
Merci de signaler tout problème par skype, mail, IRL ou bien sur <a href="https://github.com/rk-team/framewoRK/issues" target="_blank">https://github.com/rk-team/framewoRK/issues</a>.<br />
De même, si vous avez des suggestions, faites le savoir.
</div>

<div>Ce projet a pour but de permettre une prise en main rapide du framewoRK, en présentant ses différentes fonctionnalités par l'exemple.</div>

<h2>Fonctionnalités de framewoRK</h2>

<div>framewoRK a pour but de faire gagner du temps aux développeurs sans pour autant sacrifier les performances ni l'expérience utilisateur :</div>
<ul>
	<li>la plupart des composants PHP permettent de piloter simplement des <b>fonctionnalités Javascript avancées</b> (modales, ajax, ...)</li>
	<li>framewoRK offre aussi un <b>ORM simple</b> mais néanmoins puissant afin de gérer simplement la partie SQL de vos projets</li>
	<li>l'<b>internationalisation</b> de votre projet est géré, tant pour les traductions statiques de votre site, que pour les données stockées en base</li>
	<li>des systèmes de <b>mise en cache</b> des JS, CSS et de vos traductions autorisent des temps de réponse optimisé</li>
	<li>basé sur un modèle <b>fortement MVC</b>, tout ce que vous affichez provient d'un template, et vous pouvez donc personnaliser chaque élément de l'affichage</li>
</ul>


<h2>framewoRK</h2>

<div>Pour illustrer tout cela, nous allons créer un tracker de projet basique permettant de gérer des remontées utilisateur et de suivre leur état.</div>
<div>Nous partons donc d'un projet rk vierge, récupérable depuis github <a href="https://github.com/rk-team/framewoRK/archive/master.zip">ici</a>.</div>

<h3>Arborescence d'un nouveau projet</h3>

<div class="block">
	<img src="images/arborescence.png" class="illu" />
	
	<ul class="pres">
		<li>
			<b>app :</b> ce dossier contient l'ensemble des Actions (les Controlleurs du modèle MVC) de notre projet ainsi que leurs templates.<br />
			L'arborsence interne est au format <span class="path">&lt;application&gt;/modules/&lt;module&gt;/</span> et contient une classe action, ainsi qu'un dossier template.<br />
			Ce dossier contient aussi le fichier <b>config.ini</b> qui permet de définir les paramètres de configuration du projet.
		</li>
		<li>
			<b>cache :</b> ce dossier contient les différents fichiers de cache gérés par le framewoRK
		</li>
		<li>
			<b>lib :</b> ce dossier contient les sources du framework (sous dossier rk), ainsi que les classes utilisateurs (sous dossier user)
		</li>
		<li>
			<b>ressources :</b> ce dossier content l'ensemble des fichiers n'étant pas des classes PHP :
			<ul>
				<li><b>binaries :</b> fichiers binaires utilisés par le framework</li>
				<li><b>i18n :</b> fichiers XML servant à gérer les traductions statiques</li>
				<li><b>sql :</b> scripts SQL permettant de sauvegarder des fixtures</li>
				<li><b>templates :</b> ensemble des modèles servant à afficher les différents composants de l'application</li>
			</ul>
		</li>
		<li>
			<b>scripts :</b> ce dossier content l'ensemble des scripts utilisés par le framewoRK (cf <span class="todo">LIEN VERS RKTOOLS</span>)
			<ul>
				<li><span class="script">cc</span> : le script "clear cache" est chargé de supprimer tous les fichiers mis en cache dans le dossier "cache" du projet.</li>
				<li><span class="script">createClass</span> : ce script permet la génération des classes de l'ORM, en se basant sur les bases de données définies dans config.ini</li>
			</ul>
		</li>
		<li>
			<b>web :</b> ce dossier content l'ensemble des médias destinés à être servis par le projet.
		</li>
		<li>
			A la racine, se trouve un script bash <b>rkTools</b> qui permet de lancer les scrips présents dans le dossier "scripts" (cf <span class="todo">LIEN VERS RKTOOLS</span>).
		</li>
	</ul>
</div>
<div class="clear"></div>

<h3>Construction de l'affichage</h3>

<div class="block">
	<img src="images/construction_affichage.png" class="illu" />
	<div class="pres">
		<div>L'affichage d'une page est géré grâce à des templates imbriqués :</div>
		<ol class="pres">
			<li>
				<b>Layout :</b> contient les entêtes et bas de page communs à toutes les pages.<br />
				Par défaut, le layout <span class="path">ressources/templates/rk/layouts/default.php</span> est utilisé.<br />
				Afin de le personnaliser pour l'application "front", il suffit de créer le fichier <span class="path">ressources/templates/user/layouts/front.php</span> (cf <span class="todo">LIEN VERS AFFICHAGE</span>).
			</li>
			<li>
				<b>Module/Action :</b> correspond au template défini pour l'action demandée dans la requête.<br />
				Pour l'action "index" du module "home" de l'application "front", le template sera <span class="path">app/front/modules/home/templates/index.php</span> (cf <span class="todo">LIEN VERS ACTION</span>).
			</li>
			<li>
				<b>Composant 1 (optionnel) :</b> correspond au template utilisé par un composant de l'action demandée.<br />
				Par exemple, si notre action contient un pager, le template défini pour ce pager sera utilisé (par défaut : <span class="path">ressources/templates/rk/table.php</span>).<br />
				Afin d'utiliser un template de pager personnalisé appelé "myPager", il faudrait créer le fichier <span class="path">ressources/templates/user/pagers/myPager.php</span> (cf <span class="todo">LIEN VERS PAGER</span>).
			</li>
			<li>
				<b>Composant 2 (optionnel) :</b> correspond au template utilisé par un second composant de l'action demandée.<br />
				Par exemple, si notre action contient un pager, on aura par défaut un composant FormFilters intégré, et le template défini pour ce FormFilters sera donc utilisé (par défaut : <span class="path">ressources/templates/forms/filters.php</span>).<br />
				Afin d'utiliser un template de FormFilters personnalisé appelé "myFilters", il faudrait créer le fichier <span class="path">ressources/templates/user/forms/myFilters.php</span> (cf <span class="todo">LIEN VERS FORM</span>). 
			</li>
		</ol>
	</div>
</div>
<div class="clear"></div>

<a name="ORM"></a>
<h3>Fonctionnement de l'ORM</h3>

<div>L'ORM de framewoRK permet la génération automatique de classes (via le script <span class="script">createClass</span>) en lisant la définition des bases de données configurées pour le projet.</div>
<br />

<img src="images/classes_orm.png" />

<div class="block">
	<img src="images/arbo_ORM.png" class="illu" />
	
	<div class="pres">
		Prenons l'exemple d'une base de données contenant une table "report".<br />
		Si l'on appelle le script <span class="script">createClass</span>, les différentes classes générées seront :
		<ul>
			<li>
				<span class="php">\user\form\report</span> : basé sur le model. Permet de configurer l'affichage des formulaires correspond à la table "report" (cf <span class="todo">LIEN VERS FORM</span>).<br />
				<i>Ce fichier n'est généré que s'il n'existe pas, et est donc voué à être modifié.</i><br />
			</li>
			<li>
				Model :
				<ul>
					<li>
						<span class="php">\user\model\_base\report</span> : contient les attributs et références de la table "report" tels que définis en base de données.<br />
						<i>Ce fichier est regénéré à chaque appel du script <span class="script">createClass</span> et <u>ne doit donc pas être modifié</u>.</i>
					</li>
					<li>
						<span class="php">\user\model\report</span> : version utilisateur du "model\_base"<br />
						Permet par exemple de définir quel champ d'une référence étrangère utiliser pour l'affichage des formulaires (cf <span class="todo">LIEN VERS MODEL</span>).<br /> 
						<i>Ce fichier n'est généré que s'il n'existe pas, et est donc voué à être modifié.</i>
					</li>
				</ul>
			<li>
				<span class="php">\user\object\report</span> : basé sur le model. Permet de définir des méthodes spécifiques aux instances d'objets correspondants à la table "report".<br />
				Exemple : méthode "preSave" qui sera appelée avant de faire la requête de sauvegarde en base de données (cf <span class="todo">LIEN VERS OBJECT</span>).<br />
				<i>Ce fichier n'est généré que s'il n'existe pas, et est donc voué à être modifié.</i>
			</li>
			<li>
				<span class="php">\user\pager\report</span> : basé sur le model. Permet de configurer l'affichage du pager pour la table "report" (cf <span class="todo">LIEN VERS PAGER</span>).<br />
				<i>Ce fichier n'est généré que s'il n'existe pas, et est donc voué à être modifié.</i>
			</li>
			<li>
				<span class="php">\user\table\report</span> : basé sur le model. Permet d'écrire des requêtes SQL spécifiques.<br />
				<i>Ce fichier n'est généré que s'il n'existe pas, et est donc voué à être modifié.</i>
			</li>
		</ul>
		
		<div>On remarque que tous les fichiers générés sont créés dans un dossier "connector", afin de permettre de les différencier d'éventuels fichiers créés manuellement.</div>
	</div>
</div>
<div class="clear"></div>

<h3>Les pagers</h3>

<div>framewoRK permet la création rapide de "pagers" basé sur un modèle, qui se présentent par défaut sous la forme d'un tableau paginé avec des filtres de recherche.</div>

<div class="block">
	<img src="images/pager.png" class="illu" />
	<ul class="pres">
		<li>En haut, un bloc de filtres générés en fonction du modèle et de ses références en base.</li>
		<li>Au milieu, le nombre de résultats et des liens de pagination.</li>
		<li>En bas, le tableau de résultats, avec 3 boutons d'action pour chaque rapport, et un bouton d'ajout de rapport</li>
	</ul>
</div>
<div class="clear"></div>

<div>Un pager peut être configuré pour ne pas afficher de filtres et/ou ne pas gérer de pagination (et donc systématiquement afficher tous les résultats).<br />
Comme on peut aussi configurer le template à utiliser pour l'affichage du pager, ils sont utilisables dans bien des cas, dès qu'il s'agit d'afficher un ensemble de données récupérées d'une base de données.</div>


<h3>Chapitre 1 : Installation</h3>

<h4>1. Prérequis</h4>

<ul>
	<li>serveur Apache avec PHP 5.5+</li>
	<li>serveur mySQL</li>
	<li>un interpréteur BASH car les scripts n'existent pas en version Windows actuellement</li> 
</ul>

<h4>2. Configuration d'apache</h4>

<div>Nous allons définir et utiliser un nom de domaine fictif pour ce tutoriel : <span style="color: blue">trackeet.rk</span>.</div>
<pre class="bash pres">
// /etc/hosts<br />
127.0.0.1	<span style="color: blue">trackeet.rk</span></pre>

<div>Il ne reste plus qu'à définir le virtual host. En supposant que les sources soient dans <span style="color: blue">/home/www/trackeet</span> </div>

<pre class="bash pres">
// /etc/apache2/sites-available/<span style="color: blue">trackeet.rk</span>
// ou /etc/apache2/sites-available/<span style="color: blue">trackeet.rk</span>.conf selon la version du serveur apache
&lt;VirtualHost *:80>
        ServerName <span style="color: blue">trackeet.rk</span>
        DocumentRoot <span style="color: blue">/home/www/trackeet</span>/web
        &lt;Directory />
                Options +ExecCGI
                AllowOverride All
        &lt;/Directory>
&lt;/VirtualHost></pre>

<div>Activation du site et reload d'apache</div>
<pre class="bash">
sudo a2ensite <span style="color: blue">trackeet.rk</span>
sudo service apache2 reload
</pre>

<div>On s'assure ensuite qu'apache ait le droit sur les sources :</div>
<pre class="bash">cd <span style="color: blue">/home/www/trackeet</span>
sudo chmod -R 755 .
sudo chmod -R 775 ./cache
sudo chmod -R 775 ./web/uploads
</pre>

<h4>3. Le fichier de configuration</h4>

<div>Voici le contenu du fichier de config <span class="path">/app/config.ini</span></div>

<div class="block">
<pre class="bash illu">
[project]
default_application = front
languages = [fr, en]
default_language = fr
dbg_IPS = [127.0.0.1]
dev_IPS = [127.0.0.1]

[db]
default.type=mysql
default.host=localhost
default.port=3306
default.user=rk
default.password=rk
default.database=trackeet

default.behaviours.creationDate.requires_field=date_added
default.behaviours.updateDate.requires_field=date_updated</pre>
	<div class="pres">
		Les paramètres de configuration sont décrits de la façon suivante :<br />
		<span class="bash">[project]</span> : catégorie du paramètre<br />
		<span class="bash">default_application</span> : nom du paramètre<br />
		<span class="bash">front</span> : valeur du paramètre<br />
		<br />
		<div>Pour accèder à ce paramètre, il faut appeler <span class="php">\rk\manager::getConfigParam('project.default_application')</span></div>
		<br />
		<div>On remarque que certaines valeurs sont des tableaux comme <span class="bash">languages = [fr, en]</span>. Appeler <span class="php">\rk\manager::getConfigParam('project.languages')</span> retournera un tableau PHP avec 2 valeurs : "fr" et "en".</div>
	
	</div>
</div>
<div class="clear"></div>
<ul>
	<li>
		<span class="bash">[project]</span> : configuration commune à toutes les applications
		<ul>
			<li><span class="bash">project.default_application</span> : nom de l'application à utiliser quand aucune application n'est fournie dans l'URL</li>
			<li><span class="bash">project.languages</span> : liste des langues disponibles pour le projet</li>
			<li><span class="bash">project.default_language</span> : langue par défaut</li>
			<li><span class="bash">project.dbg_IPS</span> : liste des IPs pour lesquelles la barre de WebLogs apparaitra</li>
			<li><span class="bash">project.dev_IPS</span> : liste des IPs pour lesquelles l'accès au mode "dev" est autorisé. Le mode dev permet d'obtenir les versions non minifiées des JS et CSS, ainsi que la regénération des caches i18n et d'autoload PHP.<br />
			L'activation de ce mode a donc un impact conséquent sur les performances et ne devrait jamais être utilisé sur un serveur de production.</li>		
		</ul>
	</li>
	<li><span class="bash">[db]</span> : configuration des bases de données<br />
		Pour chaque base de données à utiliser sur le projet, on doit lui donner un nom (ici "default") et un certains nombres de paramètres décrits ci-après.<br />
		Si la base a un nom autre que "default", ce nom sera utilisé dans le namespacing de l'ORM et devra être fournie pour récupérer les instances de table (ex avec une base de données nommée "trackeet" : <span class="php">\rk\table::on('trackeet\report')</span> et <span class="php">\user\form\trackeet\report</span> au lieu de <span class="php">\rk\table::on('report')</span> et <span class="php">\user\form\report</span>).<br />
		Chaque base de données doit être décrite de la façon suivante :
		<ul>
			<li><span class="bash">db.&lt;name&gt;.type</span> type de SGBD. Supportés actuellement : mysql et pgsql</li>
			<li><span class="bash">db.&lt;name&gt;.host</span> host du serveur</li>
			<li><span class="bash">db.&lt;name&gt;.port</span> port du serveur</li>
			<li><span class="bash">db.&lt;name&gt;.user</span> utilisateur du serveur</li>
			<li><span class="bash">db.&lt;name&gt;.password</span> mot de passe pour l'utilisateur</li>
			<li><span class="bash">db.&lt;name&gt;.database</span> nom de la base de donnée</li>
			<li><span class="bash">db.&lt;name&gt;.behaviours</span> définition des comportements<br />
				Les comportements sont des traitement automatiques à appliquer suivant des noms de champs.<br />
				Deux comportements existent actuellement : 
				<ul>
					<li><span class="bash">creationDate</span> définit via "requires_field" : si une table a un champ &lt;valeur de la conf&gt;, il sera automatiquement utilisé lors d'un INSERT en base pour contenir la date et heure d'insertion</li> 
					<li><span class="bash">updateDate</span> définit via "requires_field" : si une table a un champ &lt;valeur de la conf&gt;, il sera automatiquement utilisé lors d'un UPDATE en base pour contenir la date et heure de mise à jour du champ</li> 
				</ul>
				Il existe un comportement "i18n" qui se base sur des suffixes de table, mais non utilisé dane ce tutoriel <span class="todo">lien vers i18n en base</span>
			</li>
		</ul>
	</li>
	
</ul>


<h3>Chapitre 2 : "Mon premier CRUD"</h3>

<h4>A. Préparation de la base + génération des classes ORM</h4>

<div>Nous allons dans ce chapitre mettre en place notre premier CRUD (Create Read Update Delete).</div>
<div>Pour cela, nous allons créer et utiliser les tables "report", qui contiendra toutes les demandes utilisateurs enregistrées, 
et "category" qui nous permettra d'attribuer à chaque demande une catégorie (et accessoirement, de voir comment se comportent les Foreign Key dans framewoRK)</div>
<div>Je vous propose donc le script de création SQL suivant : </div>
<pre class="sql">
CREATE DATABASE `trackeet` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;
USE `trackeet`;


CREATE TABLE IF NOT EXISTS `category` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(250) COLLATE utf8_bin NOT NULL,
  `description` text COLLATE utf8_bin NOT NULL,
  `date_added` datetime DEFAULT NULL,
  `date_updated` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_bin AUTO_INCREMENT=3 ;

INSERT INTO `category` (`id`, `name`, `description`, `date_added`, `date_updated`) VALUES
(1, 'PHP', 'Toute remarque relative au PHP', NULL, NULL),
(2, 'Javascript', 'Toute remarque relative au Javascript', NULL, NULL);



CREATE TABLE IF NOT EXISTS `report` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `category_id` int(11) unsigned NOT NULL,
  `author` varchar(250) COLLATE utf8_bin NOT NULL,
  `description` text COLLATE utf8_bin,
  `name` varchar(250) COLLATE utf8_bin NOT NULL,
  `type` enum('EVOL','BUG','DOC') COLLATE utf8_bin NOT NULL,
  `date_added` datetime DEFAULT NULL,
  `date_updated` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `category_id` (`category_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin AUTO_INCREMENT=2 ;

ALTER TABLE `report`
  ADD CONSTRAINT `report_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`);

INSERT INTO `report` (`id`, `category_id`, `author`, `description`, `name`, `type`, `date_added`, `date_updated`) VALUES
(1, 1, 'rophle', 'My first report !', 'First report', 'EVOL', '2014-11-24 13:45:36', '2014-11-24 13:45:36'); 


CREATE USER 'rk'@'localhost' IDENTIFIED BY 'rk';
GRANT ALL PRIVILEGES ON `trackeet` . * TO 'rk'@'localhost' WITH GRANT OPTION ;
</pre>

<div>Une fois les tables créées, il faut demander la génération des classes de l'ORM grâce à <span class="script">./rkTools createClass --all</span></div>

<div class="block">
	<img src="images/createClass.png" class="illu" />
	
	<div class="pres">On constate que le script a créé tous les fichiers (modèle de base + modèle, table, form, pager et object) pour les table "report" et "category".</div>
</div>
<div class="clear"></div>



<h4>B. Création du module</h4>

<div class="block">
	<img src="images/creation_module_report.png" class="illu" />
	
	<div class="pres">
		Nous allons ajouter un module "report" à notre application front : il suffit de créer un dossier "report" dans le dossier <span class="path">app/front/modules</span> et d'y placer un fichier "report.class.php".<br />
		Nous pouvons aussi y ajouter un dossier "templates" servant à stocker le template propre à chacune des actions de notre module. Cependant, comme nous allons utiliser la méthode getCrud, nous n'avons pas besoin de template au niveau de l'action.
	</div>
</div>
<div class="clear"></div>

<br /><br />
<div>Mettons dans "report.class.php" le contenu suivant </div>

<div class="block">
	<pre class="php illu">&lt;?php
	
namespace user\front\modules\report;

class index extends \rk\app\action {
	
	public function execute() {
		$this->getCrud('report', $this->params);
	}
	
}</pre>
	
	<ul class="pres">
		<li><span class="php">namespace user\front\modules\report;</span> : les classes d'actions doivent respecter le namespace suivant : <span class="php">user\&lt;application&gt;\modules\&lt;module&gt;</span></li>
		<li><span class="php">class index extends \rk\app\action</span> : pour chaque action du module "report", nous devons définir une classe étendant <span class="php">\rk\app\action</span></li>
		<li><span class="php">public function execute</span> : les actions doivent avoir une méthode publique <span class="php">execute</span> qui sera appelée pour générer l'affichage de l'action</li>
		<li><span class="php">$this->getCrud('report', $this->params);</span> : pour notre action, nous allons nous contenter d'appeler la méthode <span class="php">getCrud</span> en lui demandant un CRUD basé sur le model "report". Cette méthode instanciera un objet de classe <span class="php">\rk\crud</span></li>
	</ul>
</div>
<div class="clear"></div>

<br />
<br />
<div>
	Dans framewoRK, les URL sont au format <span class="url">/_&lt;app&gt;/&lt;module&gt;/&lt;action&gt;</span>, chaque partie étant optionnelle.
	<ul>
		<li>
			<b>_&lt;app&gt;</b> : nom de l'application (préfixé par un "_").<br />
			Si absent, le paramètre <span class="config">project.default_application</span> de la configuration sera utilisé (valeur par défaut : front).<br />
			Par exemple, si on rajoute une application "back", on y accèdera via des URLs commençant par <span class="url">/_back/</span>.
		</li>
		<li>
			<b>&lt;module&gt;</b> : nom du module<br />
			Si absent, framewoRK ira automatiquement chercher un module appelé "home" dans l'application trouvée.<br />
			Par exemple, dans notre cas, nous avons rajouté un module "report" dans l'application "front" (qui correspond au paramètre <span class="config">project.default_application</span>), et nous pouvons donc y accèder 
			via <span class="url">/_front/report</span> ou plus simplement <span class="url">/report</span>.
		</li>
		<li>
			<b>&lt;action&gt;</b> : nom de l'action<br />
			Si absent, framewoRK ira automatiquement chercher une action appelée "index" dans le module trouvé.<br />
			Par exemple, si on rajoutait une action "statistics" dans notre module "report", on y accèderait via <span class="url">/report/statistics</span>.
		</li>
	</ul>
</div>

<div>Comme nous sommes en plein développement, nous allons rajouter /dev au début de toutes les URLs.<br />
Ce paramètre permet de demander au framewoRK de regénérer tous les caches à chaque appel de page. Sans cela, il faudrait vider le cache (<span class="script">./rkTools cc</span>) à chaque ajout de classe.</div>

<div>Nous allons donc nous rendre sur <span class="url">/dev/report</span> pour voir notre CRUD.</div>

<h4>C. Présentation</h4>

<div class="todo">MAJ IMG</div>

<div class="block">
	<img src="images/module_report_1.png" class="illu" />
	
	<div class="pres">
		Nous obtenons l'affichage d'une instance de <span class="php">\user\pager\report</span>.
		<ul>
			<li>
				En haut : des <b>filtres de recherche</b> automatiquement intégrés affiché via un <span class="php">\rk\form\filters</span> basé sur <span class="php">\user\model\report</span>.<br />
				On trouve un filtre (input ou select selon le type de champ en base) pour chacun des attributs de notre modèle, à l'exception de la clé primaire.<br />
				On trouve aussi un filtre pour chacun des champs des références du modèle.<br /><br />
				 
				<b>Dans notre cas :</b>
				<ul>
					<li>on retrouve un filtre pour chaque attribut du modèle "report" (sauf category.id, voir plus bas)</li>
					<li>le modèle "report" a une référence sur "category", et on retrouve donc "category.id", "category.name" et "category.description" dans nos filtres.</li>
				</ul><br />
				Le filtre "category.id" semble doublé. En réalité, ce n'est pas le cas car nous avons :
				<ul>
					<li>un &lt;select name="rk-form-filters[category_id]" ... &gt; qui est relatif à l'attribute "category_id" du modèle "report".</li>  
					<li>un &lt;input name="rk-form-filters[category.id]" ... &gt; qui est lui relatif à l'attribute "id" du modèle "category".</li>  
				</ul><br />
				En effet, comme une référence vers "category" est définie dans le modèle "report", framewoRK remplace automatiquement le filtre par défaut de l'attribut "category_id" par un &lt;select&gt; avec comme &lt;option&gt; les différentes valeurs existantes en base pour la table référencée.<br />
				Du coup, le filtre par défaut (qui devrait être un &lt;input type="text" name="rk-form-filters[<b>category_id</b>]" ... &gt;) est remplacé par un &lt;select name="rk-form-filters[category.id]" ... &gt;<br /> 
			</li>
			<li>
				En bas : le <b>pager</b> a proprement parler.<br />
				On voit dans le pager le report créé via le script SQL : "My first report".<br />
				On note aussi la présence d'un bouton "+" permettant d'ajouter des "report".
			</li>
		</ul>
	</div>
</div>
<div class="clear"></div>
<br />
<div class="block">
	<img src="images/add_report.png" class="illu" />
	<div class="pres">
		<div>En cliquant dessus, une fenêtre modale contenant un formulaire d'ajout de "report" s'affiche.</div>
		<div>Il s'agit de l'affichage d'une instance de <span class="php">\user\form\report</span>.</div>
		<div>
			Comme pour les <span class="php">\rk\form\filters</span>, on trouve un filtre par attribut (mais pas pour les attributs des références cette fois), sauf pour "category_id", qui a le même comportement qu'au niveau des filtres :
			il affiche au lieu du filtre par défaut un &lt;select&gt; contenant les valeurs trouvées en base pour la table "category" référencée.
		</div>
		<br />
		<div>Une fois un "report" ajouté, nous le voyons apparaître dans le pager, avec un bouton d'édition, et un bouton de suppression.</div>
	</div>
</div>
<div class="clear"></div>

<h4>D. Personnalisation des textes</h4>

<div>Maintenant que les 4 lettres de notre CRUD sont disponibles, nous allons passer à sa configuration.</div>
<br />
<div>Pour commencer, nous allons nous occuper de l'internationalisation.</div>
<div>L'ensemble des textes affichés par framewoRK utilisent un système d'internationalisation basé sur des fichiers de traduction au format XML éditables dans <span class="path">ressources/i18n/user</span>.</div>
<div>Pour traduire les différents textes affichés par le pager "report", nous allons devoir créer 2 fichiers de traductions : "report.i18n.xml" et "category.i18n.xml" qui contiendront chacun une entrée par attribut du modèle.</div>

<div class="block">
	<pre class="xml illu">
// ressources/i18n/user/report.i18n.xml
&lt;sourceList>
	&lt;source key="report.author">
		&lt;trans lang="fr">Auteur&lt;/trans>
		&lt;trans lang="en">Author&lt;/trans>	
	&lt;/source>
	&lt;source key="report.description">
		&lt;trans lang="fr">Description&lt;/trans>
		&lt;trans lang="en">Description&lt;/trans>	
	&lt;/source>
	&lt;source key="report.name">
		&lt;trans lang="fr">Nom&lt;/trans>
		&lt;trans lang="en">Name&lt;/trans>	
	&lt;/source>
	&lt;source key="report.type">
		&lt;trans lang="fr">Type&lt;/trans>
		&lt;trans lang="en">Type&lt;/trans>	
	&lt;/source>
	&lt;source key="report.category_id">
		&lt;trans lang="fr">Catégorie&lt;/trans>
		&lt;trans lang="en">Category&lt;/trans>	
	&lt;/source>
&lt;/sourceList>
	</pre>
	<pre class="xml illu">
// ressources/i18n/user/category.i18n.xml
&lt;sourceList>
	&lt;source key="category.name">
		&lt;trans lang="fr">Nom&lt;/trans>
		&lt;trans lang="en">Name&lt;/trans>	
	&lt;/source>
	&lt;source key="category.description">
		&lt;trans lang="fr">Description&lt;/trans>
		&lt;trans lang="en">Description&lt;/trans>	
	&lt;/source>
&lt;/sourceList>
	</pre>
</div>
<div class="clear"></div>

<br />
<br />
<div>Nous avons traduit les clés générées par le framewoRK en fonction de nos modèles, et nous souhaitons maintenant surcharger certains textes trop génériques dans les modales.</div>
<div>Pour cela, nous allons donner des paramètres supplémentaires à <span class="php">getCrud</span> dans notre action.</div>

<div class="block">
	<pre class="php illu">
	public function execute() {
		$this->getCrud('report', $this->params, <b>array(
			'buttons' => array(
				'add'		=> array(
					'windowTitle'	=> i18n('report.window_add'),
				),
				'edit'	=> array(
					'windowTitle'	=> i18n('report.window_edit'),
				),
				'delete'	=> array(
					'windowTitle'	=> i18n('report.window_delete'),
				),
			)
		)</b>);
	}
	</pre>
	
	<div class="pres">
		Pour chacun des boutons, les paramètres suivants sont accessibles :
		<ul>
			<li><b>windowTitle</b> : texte à utiliser comme titre pour la modale</li>
			<li><b>class</b> : contenu de l'attribut "class" du bouton. Attention, pour qu'un lien s'ouvre en modale grâce au manager de fenêtres Javascript du framewoRK, il faut qu'il ait la classe "rkModale" (ou "rkConfirm" pour un confirm). <span class="todo">cf fenêtres Javascript</span></li>
		</ul>
	</div>
</div>
<div class="clear"></div>


<div>La barre de WebLogs affichée en mode "debug" permet d'obtenir la liste de toutes les clés de traduction demandées mais non trouvées pendant l'appel à une page.</div>
<div>Pour y accèder, il suffit de cliquer sur "WebLogs" pour faire apparaitre la liste des requêtes loggées, puis de cliquer sur la requête de son choix, et d'aller dans l'onglet "ERROR".</div>
<br />
<div>
	On constate que dans notre cas, les 3 traductions utilisées dans notre action doivent être ajoutées :
	<ul>
		<li><b>report.window_add</b> : titre de la modale d'ajout</li>
		<li><b>report.window_edit</b> : titre de la modale d'édition</li>
		<li><b>report.window_delete</b> : titre de la modale d'édition</li>
	</ul>
	<div>Note : ces clés de traductions sont appelées à l'affichage du pager (et non à l'affichage des modales d'ajout/édition/suppression), car le DOM de ce dernier contient les textes correspondants dans des attributs "data-*" qui sont pris en compte par le manager Javascript de fenêtres.</div>
</div>


<br />
<br />
<div>Pour finir, nous allons modifier certains textes du framewoRK qui ne sont pas paramétrables, comme "Filtres de recherche".</div>
<div>Pour cela, il suffit de créer un fichier de traduction qui surchargera celui du framewoRK.</div>
<pre class="xml">
// ressources/i18n/user/pager.i18n.xml
&lt;sourceList>
	&lt;source key="pager.filters_title">
		&lt;trans lang="fr">Filtres&lt;/trans>
		&lt;trans lang="en">Filters&lt;/trans>
	&lt;/source>
&lt;/sourceList>
</pre>



<h4>E. Personnalisation des composants</h4>

<div>
	Un CRUD est constitué de 3 composants (voir <a href="#ORM">Fonctionnement de l'ORM</a>):
	<ul>
		<li>un <span class="php">\user\form\report</span> qui étend <span class="php">\rk\form</span> et est utilisé pour les formulaires de création et d'édition</li>
		<li>un <span class="php">\rk\form\filters</span> basé sur <span class="php">\user\model\report</span> qui gère les filtres du pager</li>
		<li>un <span class="php">\user\pager\report</span> qui étend <span class="php">\rk\pager</span> et correspond au pager en lui même</li>
	</ul>
	Pour le configurer, il faut donc configurer chacun de ses 3 composants.
</div>

<h5>1. Le formulaire</h5>

<div>Depuis la classe de form de report, on peut facilement choisir quels champs faire apparaitre, ainsi que leur ordre.</div>
<div>Comme on a un filtre par attribut du modèle, on connaît le nom des widgets existants sur le form, et pour réordonner nos filtres, on peut par exemple modifier la méthod init de <span class="php">\user\form\report</span> comme suit :</div>
<pre class="php">
// lib/user/form/connector/report.class.php
protected function init() {
	$this->orderWidgets(array('author', 'name', 'category_id', 'type', 'description'));
}
</pre>

<div>Nous allons maintenant modifier le nom du champ à utiliser pour les &lt;option&gt; du &lt;select&gt; "Catégorie".</div>
<div>Comme celui-ci est basé sur une référence du modèle, nous allons configurer cette référence pour lui indiquer qu'elle doit systématiquement utiliser l'attribut "name" de category.</div>
<div>Pour cela, nous allons modifier <span class="php">\user\model\report</span> :</div>
<div class="block">
	<pre class="php illu">
// lib/user/model/connector/report.class.php
public function init() {
	parent::init();
	$this->getReference('report_ibfk_1')->setFields('name');
}</pre>
	<div class="pres">
		<span class="php">report_ibfk_1</span> correspond au nom de la référence en base de données. On peut aussi le retrouver depuis <span class="php">\user\model\_base\report</span>
	</div>
</div>
<div class="clear"></div>
<div>Un F5 nous permet de voir que le filtre correspond à l'attribut "category_id" a lui aussi été impacté par la modification de la référence.</div>

<h5>2. Les filtres</h5>

<div>Pour personnaliser nos filtres, nous allons à nouveau modifier <span class="php">\user\form\report</span> en utilisant le même principe que pour le formulaire.</div>
<div class="block">
	<pre class="php">// lib/user/form/connector/report.class.php
public static function configureFilters(\rk\form $form) {
	parent::configureFilters($form);
	$form->addWidgets(new \rk\form\widget\text('id', array('label' => 'report.id')));
	$form->orderWidgets(array('id', 'category_id', 'type', 'name', 'author'));
}</pre>
	<div class="pres">On note qu'on créé un widget "id" de type "text", car les filtres pour les clés primaires ne sont pas affichés automatiquement.</div>
</div>
<div class="clear"></div>

<h5>3. Le pager</h5>

<div>Pour personnaliser notre pager, nous allons modifier <span class="php">\user\pager\report</span>, toujours sur un principe similaire.</div>

<pre class="php">
// lib/user/pager/connector/report.class.php
protected function init() {
	parent::init();
	$this->orderColumns(array('category_id', 'type', 'name', 'author'));
}</pre>

<div>Nous voulons maintenant afficher la colonne id, car elle est dans notre cas bien utile pour identifier nos "report".</div>
<div class="block">
	<pre class="php illu">
// lib/user/pager/connector/report.class.php
protected function init() {
	parent::init();
	$this->setColumn(array(
		'name'	=> 'id', 
		'label' => 'report.id'
	));
	$this->orderColumns(array('id', 'category_id', 'type', 'name', 'author'));
}</pre>
	<div class="pres">
		On demande au pager de créer une colonne appellée "id" et avec comme titre la clé de traduction "report.id".<br />
		Le pager utilise automatiquement l'attribut du modèle ayant le même identifiant pour récupérer les valeurs. 
	</div>
</div>
<div class="clear"></div>


<h3>Chapitre 3 : Gestion utilisateur</h3>

<h4>1. Création de la table "user" et mise en place de la classe "\user\user"</h4>

<div>Tout d'abord, nous allons créer notre table utilisateur, puis relancer notre script de génération de classes <span class="script">./rkTools createClass --all</span></div>

<pre class="sql">
CREATE TABLE IF NOT EXISTS `user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `login` varchar(250) COLLATE utf8_bin NOT NULL,
  `password` varchar(250) COLLATE utf8_bin NOT NULL,
  `admin` tinyint(3) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

INSERT INTO `user` (`id`, `login`, `password`, `admin`) VALUES
(1, 'admin', 'admin', 1), (2, 'user1', 'user1', NULL);
</pre>

<div>Nous allons ensuite modifier la classe <span class="php">\user\user</span> qui représente un utilisateur connecté au site.</div>

<div class="block">
	<pre class="php illu">
// lib/user/user.class.php
public function login($login, $password) {
	$res = \rk\db\table::on('user')->getOneByArray(array(
		'login'		=> $login, 
		'password'	=> $password
	));
	
	if(!empty($res)) {
		$this->data = $res;
		$this->userName = $res['login'];
		$this->authentified = true;
		
		if(!empty($this->data['admin'])) {
			$this->groups[] = 'ADMIN';
		}
		
		return true;
	}
	return false;
}


public function getId() {
	if(!empty($this->data['id'])) {
		return $this->data['id'];
	}
	
	return false;
}
	</pre>
	<div class="pres">
		Dans la méthode "login", on fait une requête sur la table "user" avec les login et password donnés, si un résultat est trouvé :
		<ul>
			<li>On sauvegarde les données dans <span class="php">$this->data</span> afin de pouvoir y accéder pendant tout le reste de l'exécution du script.</li>
			<li>L'attribut "userName" sera utilisé dans le reste du framewoRK pour afficher le nom de l'utilisateur, il faut donc le remplir spécifiquement.</li>
			<li>On précise que l'utilisateur est authentifié via <span class="php">$this->authentified</span></li>
			<li>Et enfin, on prend en compte le champ "admin" de la table user pour ajouter l'utilisateur au groupe "ADMIN".</li> 
		</ul>
		La méthode "getId" doit être implémentée et retourner l'identifiant unique de votre utilisateur (en général cela sera la clé primaire de votre table utilisateur).
	</div>
</div>
<div class="clear"></div>

<h4>2. Création des formulaires login et logout</h4>

<div>Nous allons maintenant mettre en place 2 forms login et logout (qui seront des \rk\form non basés sur des modèles), ainsi qu'un pager de gestion des utilisateurs.</div>

<div class="block">
	<pre class="php illu">
// lib/user/form/login.class.php

namespace user\form;

class login extends \rk\form {
	
	public function init() {
		$this->addWidgets(array(
			new \rk\form\widget\text('login', array(
				'label' => '', 
				'placeholder' => i18n('user.login_label', array(), array('htmlentities' => true))
			)),
			new \rk\form\widget\password('password', array(
				'label' => '', 
				'placeholder' => '***'
			)),
		));
		
		$this->setParams(array(
			'template'		=> 'div.php',
			'submitName'	=> 'user.login_button'
		));
	}
	
	
	public function handleSubmit(array $formValues = array(), array $options = array()) {
		$parentValid = parent::handleSubmit($formValues, $options);
		
		if($parentValid && !empty($formValues[$this->getName()])) {
			$user = \rk\manager::getUser()->login(
				$formValues[$this->getName()]['login'], 
				$formValues[$this->getName()]['password']
			);
			
			if(empty($user)) {
				$this->addError('user.invalid_logins');
				return false;
			}
			
			return true;
		}
	}
}</pre>
	<div class="pres">
		On créé la classe <span class="php">\user\form\login</span> qui va directement hériter de <span class="php">\rk\form</span> et on lui ajoute 2 widgets
		<ul>
			<li>
				Un input type texte (<span class="php">\rk\form\widget\text</span>) appellé "login", sans libellé et avec comme attribut placeholder la clé "user.login_label"<br />
				On note aussi passage qu'on donne en troisième paramètre de la fonction <span class="php">i18n()</span> un tableau avec <span class="php">'htmlentities' => true</span>, ce qui permet à la valeur de l'input d'être "htmlentitiesée"
			</li>
			<li>
				Un input type password (<span class="php">\rk\form\widget\password</span>) appelé "password", sans libellé et avec "***" comme placeholder.
			</li>
		</ul>
		On précise ensuite qu'on veut que ce form utilise le template "div.php" (<span class="path">ressources/templates/rk/forms/div.php</span>), et que le bouton de validation du formulaire doit avoir un bouton avec "user.login_button" en texte.<br />
		<br />
		<div>Il nous reste ensuite à surcharger la méthode "handleSubmit" qui est appelée quand le formulaire est validé : nous souhaitons tester les identifiants fournis par l'utilisateur quand il soument le form.</div>
		<div>Pour cela, on commence par appeler la méthode "handleSubmit" de <span class="php">\rk\form</span> qui permet notamment de vérifier que tous les champs requis ont bien été renseignés.</div>
		<div>Ensuite, on appelle la méthode "login" de \rk\manager::getUser() pour vérifier les identifiants donnés.</div>
	</div>
</div>
<div class="clear"></div>

<div class="block">
	<pre class="php illu">
// lib/user/form/logout.class.php

namespace user\form;

class logout extends \rk\form {
	
	public function init() {
		$this->addWidgets(array(
			new \rk\form\widget\hidden('logout', array(
				'value'	=> 1,
			)),
		));

		$this->setParams(array(
			'template'		=> 'div.php',
			'submitName'	=> 'user.logout_button'
		));
	}
}</pre>
	<div class="pres">
		Pour le formulaire de logout, on a seulement besoin d'un &lt;input type="hidden"&gt;.
	</div>
</div>
<div class="clear"></div>

<h4>3. Intégration des formulaires</h4>

<div>Pour gérer ces formulaires, nous allons créer un module "user".</div>

<pre class="php">
// app/front/modules/user/user.class.php
function execute() {
	if(!\rk\manager::getUser()->isAuth()) {			// l'utilisateur n'est pas authentifié
		$form = $this->getNewForm('login');			// on récupère un formulaire de classe "login"
		$form->handleSubmit(\rk\manager::getRequestParams());	// appelle la méthode de gestion du submit de notre form
	
		if($form->hasBeenSubmitted() && $form->isValid()) {
			// si le form est valide, c'est que l'utilisateur a été loggé
			// le form a afficher devient celui de logout 
			$form = $this->getNewForm('logout');
		}
	} else {
		// même logique, mais inversée
		$form = $this->getNewForm('logout');
		$form->handleSubmit(\rk\manager::getRequestParams());
	
		if($form->hasBeenSubmitted() && $form->isValid()) {
			\rk\manager::getUser()->logout();
			$form = $this->getNewForm('login');
		}
	}

	$form->setParam('noAjax', true);			// force le submit sans ajax afin de rafraîchir tout le contenu de la page.
	$form->setParam('destination', \rk\manager::getRequestURL());	// Comme "action" du form, on utilise l'URL appelée pour la dernière action 
	
	$this->tplParams['form'] = $form;

	$this->setTemplate('index.php');
}
</pre>

<div class="block">
	<pre class="php">
// app/front/modules/user/templates/index.php
&lt;?php if($rkUser->isAuth()): ?>
<span class="welcome">&lt;?php echo i18n('user.welcome', array('userName' => $rkUser->getUserName())) ?></span>
&lt;?php endif; ?>
&lt;?php if(!empty($form)): ?>
&lt;?php echo $form; ?>
&lt;?php endif; ?></pre>
	<div class="pres">La variable $rkUser est disponible dans tous les templates et permet d'accéder à l'utilisateur.</div>
</div>
<div class="clear"></div>

<div>On peut maintenant tester nos formulaires via <span class="url">/dev/user</span></div>

<div>Pour intégrer ce bloc de login/logout à notre projet, nous allons modifier le layout de notre application :</div>
<div class="block"></div>
<pre class="php illu">
// ressources/templates/user/layouts/front.php
&lt;!doctype html&gt;
&lt;html lang="&lt;?php echo $language ?&gt;"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;&lt;?php echo $title ?&gt;&lt;/title&gt;
  
&lt;?php echo $jsContent ?&gt;
&lt;?php echo $cssContent ?&gt;
  
&lt;/head&gt;
&lt;body&gt;
	&lt;div id="wrapper"&gt;
		&lt;div id="header"&gt;
			&lt;?php echo $userContent ?&gt;
		&lt;/div&gt;
		
		&lt;div id="mainContainer"&gt;
			&lt;?php echo $content ?&gt;
		&lt;/div&gt;
		
		&lt;div id="footer"&gt;
		&lt;/div&gt;
	&lt;/div&gt;
	&lt;script type="text/javascript"&gt;
	rk.box.manage().addLinksHandler();
	&lt;?php echo \rk\webLogger::getLogsJSOutput(); ?&gt;
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
	<div class="pres">
		On remarque au passage que certaines variables sont accessibles depuis le layout :
		<ul>
			<li><span class="php">$language</span> : correspond à la langue du user loggé (récupérée depuis les préférences du browser)</li>
			<li><span class="php">$title</span> : correspond au titre de la page</li>
			<li><span class="php">$jsContent</span> : contient les sources Javascript (minifiées en mode normal, et servies fichier par fichier en mode dev)</li>
			<li><span class="php">$cssContent</span> : meme principe que $jsContent</li>
			<li><span class="php">$userContent</span> : variable spécifique qu'on va ajouter dans notre application (cf ci après)</li>
			<li><span class="php">$content</span> : contenu de l'action appelée dans la requête</li>
			<li><span class="js">rk.box.manage().addLinksHandler();</span> : permet la prise en compte automatique des liens rkModale, rkConfirm, ...</li>
			<li><span class="php">\rk\webLogger::getLogsJSOutput();</span> : permet de remplir la barre de WebLogs</li>
		</ul>
	</div>
<div class="clear"></div>

<div class="block"></div>
	<pre class="php illu">
// app/front/application.class.php
public function getOutput($moduleName, $actionName, array $params = array()) {
		
	$userContent = $this->includeAction('user', 'index', $params);
	
	$this->addToTplParams('userContent', $userContent);
	
	return parent::getOutput($moduleName, $actionName, $params);
}</pre>
	<div class="pres">Ici on surcharge la méthode getOutput de notre application, afin qu'elle exécute l'action "index" du module "user" avant de gérer l'action demandée dans l'URL. Le contenu de l'action sera placée dans une variable nommée "userContent" au niveau de notre layout.</div>
<div class="clear"></div>
<br />
<div>Reste à faire évoluer la table report, pour qu'elle se base sur un user_id et non plus sur un champs "author"</div>
<pre class="sql">
ALTER TABLE `report` DROP `author`;
ALTER TABLE `report` ADD `user_id` INT UNSIGNED NOT NULL AFTER `id`;
ALTER TABLE `report` ADD INDEX ( `user_id` );
UPDATE `report` SET user_id = 1;
ALTER TABLE `report` ADD FOREIGN KEY ( `user_id` ) REFERENCES `trackeet`.`user` (
`id`
) ON DELETE RESTRICT ON UPDATE RESTRICT ;
</pre>

<div>Il nous faut maintenant relancer le script <span class="script">createClass</span>, puis mettre à jour la classe de pager et le form, pour y remplacer "author" par "user_id".</div>

<div class="block">
	<pre class="php illu">
// lib/user/form/connector/report.class.php
protected function init() {
	$this->changeWidgetType('user_id', 'hidden');
	if($this->isNew()) {
		$this->getWidget('user_id')->setValue(\rk\manager::getUser()->getId());
	}
	$this->orderWidgets(array('user_id', 'name', 'category_id', 'type', 'description'));
}</pre>
	<div class="pres">
		<span class="php">changeWidgetType</span> permet de changer le type du widget "user_id" (qui est un select en principe) en un input hidden. Il conserve tous ses paramètres.<br />
		On utilise la méthode "isNew()" qui permet de savoir si l'objet édité dans le form est un nouvel objet ou s'il correspond à un objet existant en base. 
		Dans le cas où le form porte sur un nouvel objet, on lui attribue comme user_id l'id de l'utilisateur connecté. 
	</div>
</div>
<div class="clear"></div>

<div class="block">
	<pre class="php illu">
// lib/user/pager/connector/report.class.php (méthode init)
$this->orderColumns(array('id', 'category_id', 'type', 'name', 'user_id'));
</pre>
	<div class="pres">Niveau pager, on va juste changer la liste des colonnes</div>
</div>
<div class="clear"></div>

<div class="block">
	<pre class="php illu">
// lib/user/model/connector/report.class.php (méthode init)
$this->getReference('report_ibfk_2')->setFields('login');
</pre>
	<div class="pres">Niveau modèle, on rajoute cette ligne pour indiquer au framewoRK d'utiliser la colonne "login" de la table "user" pour les afficher</div>
</div>
<div class="clear"></div>


<div>Les données s'affichent maintenant correctement, mais un problème a été créé : quand on est pas authentifié, on peut accéder au formulaire de création de rapport, mais il sera toujours en échec (car aucun user_id ne sera affectable à notre report).</div>

<h4>4. Gestion des droits</h4>

<div>Au niveau des pagers, 2 possibilités de vérification des droits existent pour les boutons : "requiresAuth" qui nécessite un utilisateur authentifié et "requiresGroup" qui nécessite un utilisateur authentifié ET un groupe.</div>

<div class="block">
	<pre class="php illu">
// app/front/modules/report/report.class.php
$this->getCrud('report', $this->params, array(
	'buttons' => array(
		'add'		=> array(
			'windowTitle'	=> i18n('report.window_add'),
			'requiresAuth'	=> true,
		),
		'edit'	=> array(
			'windowTitle'	=> i18n('report.window_edit'),
			'requiresGroup'	=> 'ADMIN',
		),
		'delete'	=> array(
			'windowTitle'	=> i18n('report.window_delete'),
			'requiresGroup'	=> 'ADMIN',
		),
		'details'	=> array(
			'type'			=> 'action',
			'target'		=> urlFor('report/details'),
			'windowTitle'	=> i18n('report.window_details'),
		),
	)
));</pre>
	<ul class="pres">
		<li>Seuls les utilisateurs authentifiés pourront rajouter un rapport</li>
		<li>Seuls les utilisateurs membres du groupe ADMIN pourront éditer ou supprimer un rapport</li>
		<li>On rajoute un lien "details" accessibles à tout le monde, et qui pointe sur l'action "details" du module "report".</li>
	</ul>
</div>
<div class="clear"></div>

<div class="todo">FRAMEWORK : rajouter un check de droit sur les similiaction du crud</div>

<div>On créé l'action "details" et son template.

<div class="block">
	<pre class="php illu">
// app/front/modules/report/report.class.php
class details extends \rk\app\action {
	
	protected $requiredParams = array('id');
	
	public function execute() {
		$report = \rk\db\table::on('report')->getByPk($this->getParam('id'), false);
		$this->tplParams['reportForm'] = $report->getForm();
		$this->tplParams['reportForm']->markAsNoEdit();
	}	
}</pre>
	<div class="pres">
		<ul>
			<li><span class="php">protected $requiredParams = array('id');</span> indique que notre action requiert un paramètre "id"
			<li><span class="php">$report = \rk\db\table::on('report')->getByPk($this->getParam('id'), false);</span> récupère notre report depuis sa table. Le second paramètre (false) permet de demander d'avoir un objet plutot qu'un tableau.</li>
			<li>On demande ensuite l'obtention d'un formulaire pour cet objet <span class="php">$this->tplParams['reportForm'] = $report->getForm();</span></li>
			<li>Et enfin, on indique qu'on veut utiliser le mode "noEdit" du form, qui permet d'afficher le contenu d'un formulaire sans &lt;form&gt; ni aucun &lt;input&gt;</li>
		</ul>
	</div>
</div>

<pre class="xml">
// app/front/modules/report/templates/details.php
&lt;div class="formNoEdit">
	&lt;fieldset>
		&lt;legend>&lt;?php echo i18n('report.label') ?>&lt;/legend>
		&lt;?php echo $reportForm->getOutput(); ?>
	&lt;/fieldset>
&lt;/div></pre>



<h3>Chapitre 4 : Gestion des commentaires</h3>

<h4>1. Mise en place</h4>

<div>Nous allons maintenant ajouter la possibilité de commenter des "report" et mettre en place un "cycle de vie" basé sur les commentaires ajoutés.</div>

<pre class="sql">
ALTER TABLE `report` ADD `status` ENUM( 'NEW', 'ACCEPTED', 'REFUSED', 'IN PROGRESS', 'DONE' ) NOT NULL;

CREATE TABLE IF NOT EXISTS `comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `report_id` int(10) unsigned NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `type` enum('COMMENT','ACCEPTING','CORRECTING','CORRECTED') COLLATE utf8_bin NOT NULL,
  `description` text COLLATE utf8_bin NOT NULL,
  PRIMARY KEY (`id`),
  KEY `report_id` (`report_id`),
  KEY `user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

ALTER TABLE `comment`
  ADD CONSTRAINT `comment_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`),
  ADD CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`report_id`) REFERENCES `report` (`id`) ON DELETE CASCADE ON UPDATE CASCADE;
</pre>

<div>Après avoir relancé <span class="script">createClass</span>, on va intégrer notre formulaire de "comment" à notre action "details".</div>

<div class="block">
	<pre class="php illu">
// app/front/modules/report/report.class.php
class details extends \rk\app\action {
	
	protected $requiredParams = array('id');
	
	public function execute() {
		$this->tplParams['id'] = \rk\manager::getUniqueId();
		
		$report = \rk\db\table::on('report')->getByPk($this->getParam('id'), false);
		$this->tplParams['reportForm'] = $report->getForm();
		$this->tplParams['reportForm']->markAsNoEdit();
		
		if(\rk\manager::getUser()->isAuth()) {
			// pour les utilisateurs authentifiés, on rajoute un formulaire d'ajout de commentaire
			$this->tplParams['commentForm'] = new \user\form\comment(
				array('report_id' => $this->getParam('id')),
				array('updateContainer' => '#' . $this->tplParams['id'])
			);
			$this->tplParams['commentForm']->handleSubmit($this->params);
		}
		
		$this->tplParams['comments'] = \rk\db\table::on('comment')->get(array('report_id' => $this->getParam('id')));
	}	
}</pre>
	<pre class="xml illu">
&lt;div id="&lt;?php echo $id ?>">
	&lt;div class="leftCol">
		&lt;fieldset>
			&lt;legend>&lt;?php echo i18n('report.label') ?>&lt;/legend>
			&lt;?php echo $reportForm->getOutput(); ?>
		&lt;/fieldset>
		
		&lt;?php if(!empty($commentForm)): ?>
		&lt;fieldset>
			&lt;legend>&lt;?php echo i18n('comment.add') ?>&lt;/legend>
			&lt;?php echo $commentForm->getOutput(); ?>
		&lt;/fieldset>
		&lt;?php endif; ?>
	&lt;/div>
	
	&lt;?php if(!empty($comments)): ?>
	&lt;div class="rightCol">
		&lt;fieldset>
			&lt;legend>&lt;?php echo i18n('report.comments') ?>&lt;/legend>
			&lt;div class="comments">
			&lt;?php foreach($comments as $oneComment): ?>
				&lt;div class="oneComment">
					&lt;div class="commentTitle">
						&lt;?php echo $oneComment['user']['login'] ?>(&lt;?php echo $oneComment['type'] ?>) :
						&lt;?php if($rkUser->hasGroup('ADMIN')): ?>
						&lt;a class="rkModale icon edit" data-rkModaleId="editComment" href="&lt;?php echo urlFor('report/editComment', array('id' => $oneComment['id'])); ?>">&lt;/a>
						&lt;a class="rkConfirm icon delete" data-rkWindowTitle="pet" href="&lt;?php echo urlFor('report/deleteComment', array('id' => $oneComment['id'])); ?>">&lt;/a>
						&lt;?php endif; ?>
					&lt;/div>
					&lt;div class="commentText" data-col="report_comment.comment" data-table="report">
						&lt;?php echo $oneComment['description'] ?>
					&lt;/div>
				&lt;/div>
			&lt;?php endforeach; ?>
			&lt;/div>
		&lt;/fieldset>
	&lt;/div>
	&lt;?php endif; ?>
	
	&lt;div class="clear">&lt;/div>
&lt;/div>
	</pre>
</div>
<div class="clear"></div>

<div>On utilise une div avec comme id <span class="php">\rk\manager::getUniqueId();</span> (identifiant unique généré en fonction du microtime) afin de pouvoir rafraichir notre contenu quand le formulaire d'édition est envoyé.</div>
<div>On intègre ensuite nos 2 formulaires (celui du report en noEdit, et celui d'ajout de commentaire).</div>
<div>Enfin, on boucle sur les commentaires récupérés depuis la base de données, et on les affiche, avec un lien d'édition et un lien de suppression pour les utilisateurs du groupe ADMIN.</div>

<div>Une fois les différentes traductions ajoutées, on va personnaliser notre formulaire de "comment", et créer les actions deleteComment et editComment.</div>

<pre class="php">
&lt;?php
// lib/user/form/connector/comment.class.php

protected function init() {
	$this->changeWidgetType('report_id', 'hidden');
	$this->changeWidgetType('user_id', 'hidden');
	if($this->isNew()) {
		$this->getWidget('user_id')->setValue(\rk\manager::getUser()->getId());
	}
	$this->orderWidgets(array('id', 'report_id', 'user_id', 'type', 'description'));
}</pre>

<pre class="php">
// app/front/modules/report/report.class.php

class deleteComment extends \rk\app\action {
	
	protected $requiredParams = array('id');
	protected $requiresGroup = 'ADMIN';
	
	public function execute() {
		\rk\db\table::on('comment')->delete(array('id' => $this->getParam('id')));
	}	
}

class editComment extends \rk\app\action {
	
	protected $requiredParams = array('id');
	protected $requiresGroup = 'ADMIN';
	
	public function execute() {
		$comment = \rk\db\table::on('comment')->getOne(array('id' => $this->getParam('id')));
		$form = $this->getForm('comment', $comment);
		$form->handleSubmit($this->params);
	}	
}
</pre>

<h4>2. Intégration au pager</h4>

<div>Nous voulons rajouter une colonne affichant le nombre de commentaires pour chaque report.</div>

<div class="block">
	<pre class="php illu">
// \user\pager\report
$this->setColumn(array(
	'name'	=> 'nb_comment',
	'label'	=> 'report.nb_comment'
));
	</pre>
	<div class="pres">On ajoute simplement une colonne nommée "nb_comment" sur notre pager.<br />
	Par défaut, elle n'affichera rien, car aucune champ nommé "nb_comment" n'est remonté par la table.</div>
</div>
<div class="clear"></div>

<div class="block">
	<pre class="php illu">
// \user\table\report
&lt;?php

namespace user\table;

class report extends \rk\db\table {
	
	public function getForPager($criterias = array(), array $params = array()) {
		$params['extraSelects']['nb_comment'] = 'select count(comment.id) from comment where comment.report_id = report.id';
		return parent::getForPager($criterias, $params);
	}
}</pre>
	<div class="pres">Et on ajoute un "extra select" du même nom sur la table.<br />
	Pour ce faire, on surcharge la méthode getForPager <span class="todo">FramewoRK : utiliser configureForPager à la place</span>.<br />
	Un "extra select" est un select SQL qui sera utilisé comme sous requête lors de la récupération des données.</div>
</div>
<div class="clear"></div>


<h4>3. Gestion de l'état d'un report</h4>

<div>Nous allons maintenant faire évoluer le "status" des report en fonction du "type" des commentaires soumis.</div>
<div>Pour cela, nous allons utiliser la fonction "postSave" disponible sur toutes les classes héritant de <span class="php">\rk\object</span>.</div>

<pre class="php">
&lt;?php

namespace user\object;

class comment extends \rk\object {
	
	protected function postSave() {
		$report = \rk\db\table::on('report')->getByPk($this['report_id'], false);
		
		switch($this['type']) {
			case 'ACCEPTING':
				$report['status'] = 'ACCEPTED';
			break;
			
			case 'CORRECTING':
				$report['status'] = 'IN PROGRESS';
			break;
			
			case 'CORRECTED':
				$report['status'] = 'DONE';
			break;
			
			case 'REFUSING':
				$report['status'] = 'REFUSED';
			break;
		}
		
		$report->save();
	}
}

</pre>



<script type="text/javascript">
$(document).ready(function() {
  $('.php, .sql, .xml, .bash, .class').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
</script>  
  </body>
</html>
